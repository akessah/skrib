---
timestamp: 'Sun Oct 19 2025 10:53:29 GMT-0400 (Eastern Daylight Time)'
content_id: 557b97c765d5564ab34672183dac41c42e39aca7f1075edf7546090a96125d4f
---

# file: src\concepts\skrib\Tagging.test.ts

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { MongoClient, Db } from "npm:mongodb";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import TaggingConcept from "./Tagging.ts"; // Corrected import path and class name

// Define test IDs
const userA = "user:Alice" as ID;
const userB = "user:Bob" as ID;
const bookX = "book:1984" as ID;
const bookY = "book:Dune" as ID;
const bookZ = "book:Foundation" as ID;




// let db: Db | null = null; // <--- Change Deno.Kv to Db (from npm:mongodb)
// let client: MongoClient | null = null; // <--- Change any to MongoClient (from npm:mongodb)
// let tagging: TaggingConcept;

let [db, client] = await testDb();
let tagging = new TaggingConcept(db as Db); // Ensure db is typed as Db for the constructor


// Setup: Initialize the database and concept instance before each test
Deno.test.afterEach(async () => {
  if (client) {
        await client.close();
        await new Promise((resolve) => setTimeout(resolve, 10));
    }

  [db, client] = await testDb();
  tagging = new TaggingConcept(db as Db);
});

// Teardown: Close the database connection after each test
Deno.test.afterAll(async () => {
    if (client) {
        await client.close();
    }
});

Deno.test("TaggingConcept: Add Tag - success", async () => {
  console.log("--- Test: Add Tag - success ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Action: Add a tag
  console.log(`User ${userA} adding tag 'dystopian' to book ${bookX}`);
  const result = await tagging.addTag({
    user: userA,
    label: "dystopian",
    book: bookX,
  });

  // Effects: Check if tag was created and returned
  assertExists(result, "Result should not be undefined");
  assertNotEquals((result as { error: string }).error, "Tag by user for this book and label already exists.", "Should not return an error for a new tag");
  const { tag: tagId } = result as { tag: ID };
  assertExists(tagId, "Tag ID should be returned");

  // Confirm state change using a query
  const tagsByUser = await tagging._getTagsByUser({ user: userA });
  assertEquals(tagsByUser.length, 1, "Should find 1 tag for userA");
  assertEquals(tagsByUser[0]._id, tagId, "The returned tag ID should match");
  assertEquals(tagsByUser[0].user, userA, "Tag's user should be Alice");
  assertEquals(tagsByUser[0].label, "dystopian", "Tag's label should be 'dystopian'");
  assertEquals(tagsByUser[0].book, bookX, "Tag's book should be 1984");
  assertEquals(tagsByUser[0].private, false, "Tag should be public by default");

  console.log(`Successfully added tag ${tagId}.`);
//   await client.close();
});

Deno.test("TaggingConcept: Add Tag - requires (duplicate)", async () => {
  console.log("--- Test: Add Tag - requires (duplicate) ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a tag first
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "fantasy",
    book: bookY,
  }) as { tag: ID };
  assertExists(tagId);
  console.log(`Initial tag ${tagId} added.`);

  // Action: Try to add the same tag again
  console.log(`User ${userA} trying to add duplicate tag 'fantasy' to book ${bookY}`);
  const result = await tagging.addTag({
    user: userA,
    label: "fantasy",
    book: bookY,
  });

  // Requires: Expect an error for duplicate tag
  assertExists((result as { error: string }).error, "Should return an error for duplicate tag");
  assertEquals(
    (result as { error: string }).error,
    "tag already added",
    "Error message should indicate duplicate tag",
  );

  // Effects: State should remain unchanged
  const tagsByUser = await tagging._getTagsByUser({ user: userA });
  assertEquals(tagsByUser.length, 1, "Should still be 1 tag for userA");

  console.log("Duplicate tag attempt correctly failed.");
//   await client.close();
});

Deno.test("TaggingConcept: Remove Tag - success", async () => {
  console.log("--- Test: Remove Tag - success ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a tag
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "sci-fi",
    book: bookZ,
  }) as { tag: ID };
  assertExists(tagId);
  console.log(`Tag ${tagId} added for removal test.`);

  // Action: Remove the tag
  console.log(`Removing tag ${tagId}`);
  const result = await tagging.removeTag({ tag: tagId });

  // Effects: Check if the tag was removed
  assertNotEquals((result as { error: string }).error, "tag doesn't exist", "Should not return an error for existing tag");
  assertEquals(result, {}, "Result should be empty object on success");

  // Confirm state change
  const tagsByUser = await tagging._getTagsByUser({ user: userA });
  assertEquals(tagsByUser.length, 0, "No tags should be found for userA after removal");
  const allTags = await tagging._getAllTags({});
  assertEquals(allTags.length, 0, "No tags should be in the database");

  console.log(`Tag ${tagId} successfully removed.`);
//   await client.close();
});

Deno.test("TaggingConcept: Remove Tag - non-existent", async () => {
  console.log("--- Test: Remove Tag - non-existent ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  const nonExistentTag = "tag:nonexistent" as ID;
  console.log(`Attempting to remove non-existent tag ${nonExistentTag}`);
  const result = await tagging.removeTag({ tag: nonExistentTag });

  // Effects: Expect an error for non-existent tag
  assertExists((result as { error: string }).error, "Should return an error for non-existent tag");
  assertEquals((result as { error: string }).error, "tag doesn't exist", "Error message should indicate tag not found");

  console.log("Removal of non-existent tag correctly failed.");
//   await client.close();
});

Deno.test("TaggingConcept: Mark Private - success", async () => {
  console.log("--- Test: Mark Private - success ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a public tag
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "adventure",
    book: bookX,
  }) as { tag: ID };
  assertExists(tagId);
  console.log(`Tag ${tagId} added and is initially public.`);

  // Action: Mark private
  console.log(`Marking tag ${tagId} private.`);
  const result = await tagging.markPrivate({ tag: tagId });

  // Effects: Check if tag is now private
  assertNotEquals((result as { error: string }).error, "tag doesn't exist", "Should not return an error for existing tag");

  const updatedTags = await tagging._getTagsByUser({ user: userA });
  assertEquals(updatedTags.length, 1);
  assertEquals(updatedTags[0].private, true, "Tag should be marked private");

  console.log(`Tag ${tagId} successfully marked private.`);
//   await client.close();
});

Deno.test("TaggingConcept: Mark Private - requires (already private)", async () => {
  console.log("--- Test: Mark Private - requires (already private) ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a tag and mark it private
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "thriller",
    book: bookY,
  }) as { tag: ID };
  await tagging.markPrivate({ tag: tagId });
  console.log(`Tag ${tagId} initially marked private.`);

  // Action: Try to mark private again
  console.log(`Attempting to mark tag ${tagId} private again.`);
  const result = await tagging.markPrivate({ tag: tagId });

  // Requires: Expect no error
  assertNotEquals((result as { error: string }).error, "tag doesn't exist", "Should not return an error for existing tag");

  const updatedTags = await tagging._getTagsByUser({ user: userA });
  assertEquals(updatedTags.length, 1);
  assertEquals(updatedTags[0].private, true, "Tag should be marked private");

  console.log(`Tag ${tagId} successfully marked private.`);
//   await client.close();
});

Deno.test("TaggingConcept: Mark Public - success", async () => {
  console.log("--- Test: Mark Public - success ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a tag and mark it private
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "biography",
    book: bookZ,
  }) as { tag: ID };
  await tagging.markPrivate({ tag: tagId });
  console.log(`Tag ${tagId} initially marked private.`);

  // Action: Mark public
  console.log(`Marking tag ${tagId} public.`);
  const result = await tagging.markPublic({ tag: tagId });

  // Effects: Check if tag is now public
  assertNotEquals((result as { error: string }).error, "tag doesn't exist", "Should not return an error for existing tag");

  const updatedTags = await tagging._getTagsByUser({ user: userA });
  assertEquals(updatedTags.length, 1);
  assertEquals(updatedTags[0].private, false, "Tag should be marked public");

  console.log(`Tag ${tagId} successfully marked public.`);
//   await client.close();
});

Deno.test("TaggingConcept: Mark Public - requires (already public)", async () => {
  console.log("--- Test: Mark Public - requires (already public) ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Precondition: Add a public tag
  const { tag: tagId } = await tagging.addTag({
    user: userA,
    label: "comedy",
    book: bookX,
  }) as { tag: ID };
  console.log(`Tag ${tagId} initially public.`);

  // Action: Try to mark public again
  console.log(`Attempting to mark tag ${tagId} public again.`);
  const result = await tagging.markPublic({ tag: tagId });

  // Requires: Expect no error
  assertNotEquals((result as { error: string }).error, "tag doesn't exist", "Should not return an error for existing tag");

  const updatedTags = await tagging._getTagsByUser({ user: userA });
  assertEquals(updatedTags.length, 1);
  assertEquals(updatedTags[0].private, false, "Tag should be marked public");

  console.log(`Tag ${tagId} successfully marked public.`);
//   await client.close();
});

Deno.test("TaggingConcept: Mark Private/Public - non-existent tag", async () => {
  console.log("--- Test: Mark Private/Public - non-existent tag ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  const nonExistentTag = "tag:nonexistent" as ID;
  console.log(`Attempting to mark non-existent tag ${nonExistentTag} private.`);
  let result = await tagging.markPrivate({ tag: nonExistentTag });
  assertExists((result as { error: string }).error, "Should return error for private non-existent");
  assertEquals((result as { error: string }).error, "tag doesn't exist");

  console.log(`Attempting to mark non-existent tag ${nonExistentTag} public.`);
  result = await tagging.markPublic({ tag: nonExistentTag });
  assertExists((result as { error: string }).error, "Should return error for public non-existent");
  assertEquals((result as { error: string }).error, "tag doesn't exist");

  console.log("Marking non-existent tag private/public correctly failed.");
//   await client.close();
});

Deno.test("TaggingConcept: Query _getTagsByBook", async () => {
  console.log("--- Test: Query _getTagsByBook ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Setup: Add various tags
  const tag1 = (await tagging.addTag({ user: userA, label: "fiction", book: bookX })) as { tag: ID };
  const tag2 = (await tagging.addTag({ user: userB, label: "classic", book: bookX })) as { tag: ID };
  const tag3 = (await tagging.addTag({ user: userA, label: "private_note", book: bookX })) as { tag: ID };
  const tag4 = (await tagging.addTag({ user: userB, label: "historical", book: bookY })) as { tag: ID };
  await tagging.markPrivate({ tag: tag3.tag }); // Make tag3 private
  console.log("Tags added: 2 public on bookX, 1 private on bookX (by userA), 1 public on bookY.");

  // Query 1: UserA gets tags for bookX
  console.log(`User ${userA} querying tags for book ${bookX}`);
  const tagsForBookX_UserA = await tagging._getTagsByBook({ user: userA, book: bookX });
  assertEquals(tagsForBookX_UserA.length, 3, "UserA should see 2 public and their 1 private tag on bookX");
  const labelsForBookX_UserA = tagsForBookX_UserA.map((t) => t.label).sort();
  assertEquals(labelsForBookX_UserA, ["classic", "fiction", "private_note"], "Labels for UserA on bookX are correct");

  // Query 2: UserB gets tags for bookX
  console.log(`User ${userB} querying tags for book ${bookX}`);
  const tagsForBookX_UserB = await tagging._getTagsByBook({ user: userB, book: bookX });
  assertEquals(tagsForBookX_UserB.length, 2, "UserB should see 2 public tags on bookX, not UserA's private tag");
  const labelsForBookX_UserB = tagsForBookX_UserB.map((t) => t.label).sort();
  assertEquals(labelsForBookX_UserB, ["classic", "fiction"], "Labels for UserB on bookX are correct");

  // Query 3: UserA gets tags for bookY (should be only public one)
  console.log(`User ${userA} querying tags for book ${bookY}`);
  const tagsForBookY_UserA = await tagging._getTagsByBook({ user: userA, book: bookY });
  assertEquals(tagsForBookY_UserA.length, 1, "UserA should only see 1 public tag on bookY");
  assertEquals(tagsForBookY_UserA[0].label, "historical", "Label for UserA on bookY is correct");

  console.log("Query _getTagsByBook tests passed.");
//   await client.close();
});

Deno.test("TaggingConcept: Query _getBooksbyLabel", async () => {
  console.log("--- Test: Query _getBooksbyLabel ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Setup: Add various tags
  const tag1 = (await tagging.addTag({ user: userA, label: "sci-fi", book: bookX })) as { tag: ID };
  const tag2 = (await tagging.addTag({ user: userB, label: "sci-fi", book: bookY })) as { tag: ID };
  const tag3 = (await tagging.addTag({ user: userA, label: "personal_sci-fi", book: bookZ })) as { tag: ID };
  const tag4 = (await tagging.addTag({ user: userB, label: "fantasy", book: bookX })) as { tag: ID };
  await tagging.markPrivate({ tag: tag3.tag }); // Make tag3 private
  console.log("Tags added: bookX has sci-fi (A), fantasy (B). bookY has sci-fi (B). bookZ has personal_sci-fi (A, private).");

  // Query 1: UserA searches for "sci-fi"
  console.log(`User ${userA} searching for label 'sci-fi'`);
  const booksWithSciFi_UserA = await tagging._getBooksByLabel({ user: userA, labels: ["sci-fi"], type: 'union' });
  assertEquals(booksWithSciFi_UserA.length, 2, "UserA should find 2 public sci-fi tags");
  const bookIdsSciFi_UserA = booksWithSciFi_UserA.map((t) => t.book).sort();
  assertEquals(bookIdsSciFi_UserA.sort(), [bookX, bookY], "Books found for 'sci-fi' by UserA are correct");

  // Query 2: UserB searches for "sci-fi"
  console.log(`User ${userB} searching for label 'sci-fi'`);
  const booksWithSciFi_UserB = await tagging._getBooksByLabel({ user: userB, labels: ["sci-fi"], type: 'intersect' });
  assertEquals(booksWithSciFi_UserB.length, 2, "UserB should find 2 public sci-fi tags");
  const bookIdsSciFi_UserB = booksWithSciFi_UserB.map((t) => t.book).sort();
  assertEquals(bookIdsSciFi_UserB.sort(), [bookX, bookY], "Books found for 'sci-fi' by UserB are correct");

  // Query 3: UserA searches for "personal_sci-fi"
  console.log(`User ${userA} searching for label 'personal_sci-fi'`);
  const booksWithPersonalSciFi_UserA = await tagging._getBooksByLabel({ user: userA, labels: ["personal_sci-fi"], type: 'intersect' });
  assertEquals(booksWithPersonalSciFi_UserA.length, 1, "UserA should find their private 'personal_sci-fi' tag");
  assertEquals(
    booksWithPersonalSciFi_UserA[0].book,
    bookZ,
    "Book found for 'personal_sci-fi' by UserA is correct",
  );

  // Query 4: UserB searches for "personal_sci-fi" (should not see UserA's private tag)
  console.log(`User ${userB} searching for label 'personal_sci-fi'`);
  const booksWithPersonalSciFi_UserB = await tagging._getBooksByLabel({ user: userB, labels: ["personal_sci-fi"], type: 'intersect' });
  assertEquals(
    booksWithPersonalSciFi_UserB.length,
    0,
    "UserB should not find UserA's private 'personal_sci-fi' tag",
  );

  // Query 5: UserA searches for union of multiple labels ("sci-fi", "fantasy", "personal_sci-fi")
  console.log(`User ${userA} searching for labels 'sci-fi', 'fantasy', 'personal_sci-fi'`);
  const booksWithMultipleLabels_UserA = await tagging._getBooksByLabel({
    user: userA,
    labels: ["sci-fi", "fantasy", "personal_sci-fi"],
    type: 'union'
  });

  assertEquals(booksWithMultipleLabels_UserA.length, 3, "UserA should find 2 public sci-fi, 1 public fantasy, and their 1 private personal_sci-fi tag");
  const bookLabelsMultiple_UserA = booksWithMultipleLabels_UserA.map((t) => t.book).sort();
  assertEquals(bookLabelsMultiple_UserA.sort(), [
    bookX,
    bookY,
    bookZ], "Combined labels for UserA are correct");

  console.log("Query _getBooksbyLabel tests passed.");
//   await client.close();
});

Deno.test("TaggingConcept: Query _getTagsByUser", async () => {
  console.log("--- Test: Query _getTagsByUser ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Setup: Add tags by different users, some private
  const tagA1 = (await tagging.addTag({ user: userA, label: "history", book: bookX })) as { tag: ID };
  const tagA2 = (await tagging.addTag({ user: userA, label: "reference", book: bookX })) as { tag: ID };
  const tagA3 = (await tagging.addTag({ user: userA, label: "secret", book: bookY })) as { tag: ID };
  const tagB1 = (await tagging.addTag({ user: userB, label: "fiction", book: bookX })) as { tag: ID };
  await tagging.markPrivate({ tag: tagA3.tag }); // Make tagA3 private
  console.log("Tags added: userA has 2 public, 1 private. userB has 1 public.");

  // Query 1: Get tags for UserA
  console.log(`User ${userA} querying their own tags`);
  const tagsForUserA = await tagging._getTagsByUser({ user: userA });
  assertEquals(tagsForUserA.length, 3, "UserA should get all 3 of their tags (public and private)");
  const labelsForUserA = tagsForUserA.map((t) => t.label).sort();
  assertEquals(labelsForUserA, ["history", "reference", "secret"], "Labels for UserA are correct");

  // Query 2: Get tags for UserB
  console.log(`User ${userB} querying their own tags`);
  const tagsForUserB = await tagging._getTagsByUser({ user: userB });
  assertEquals(tagsForUserB.length, 1, "UserB should get their 1 public tag");
  assertEquals(tagsForUserB[0].label, "fiction", "Label for UserB is correct");

  // Query 3: Get tags for a non-existent user
  console.log(`Querying tags for non-existent user 'user:Charlie'`);
  const tagsForNonExistentUser = await tagging._getTagsByUser({ user: "user:Charlie" as ID });
  assertEquals(tagsForNonExistentUser.length, 0, "Non-existent user should have no tags");

  console.log("Query _getTagsByUser tests passed.");
//   await client.close();
});

Deno.test("TaggingConcept: Query _getAllPublicTags", async () => {
  console.log("--- Test: Query _getAllPublicTags ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Setup: Add public and private tags
  const tag1 = (await tagging.addTag({ user: userA, label: "general", book: bookX })) as { tag: ID }; // Public by default
  const tag2 = (await tagging.addTag({ user: userB, label: "shared", book: bookY })) as { tag: ID }; // Public by default
  const tag3 = (await tagging.addTag({ user: userA, label: "private_topic", book: bookZ })) as { tag: ID };
  await tagging.markPrivate({ tag: tag3.tag }); // Make private
  console.log("Tags added: 2 public, 1 private.");

  // Action: Get all public tags
  console.log("Getting all public tags.");
  const publicTags = await tagging._getAllPublicTags({});

  // Effects: Only public tags should be returned
  assertEquals(publicTags.length, 2, "Should only retrieve 2 public tags");
  const publicLabels = publicTags.map((t) => t.label).sort();
  assertEquals(publicLabels, ["general", "shared"], "Only public labels should be present");
  publicTags.forEach((t) => assertEquals(t.private, false, "All returned tags must be public"));

  console.log("Query _getAllPublicTags tests passed.");
//   await client.close();
});

Deno.test("TaggingConcept: Query _getAllTags", async () => {
  console.log("--- Test: Query _getAllTags ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Setup: Add public and private tags
  const tag1 = (await tagging.addTag({ user: userA, label: "topic1", book: bookX })) as { tag: ID }; // Public
  const tag2 = (await tagging.addTag({ user: userB, label: "topic2", book: bookY })) as { tag: ID }; // Public
  const tag3 = (await tagging.addTag({ user: userA, label: "secret_topic", book: bookZ })) as { tag: ID };
  await tagging.markPrivate({ tag: tag3.tag }); // Private
  console.log("Tags added: 2 public, 1 private.");

  // Action: Get all tags
  console.log("Getting all tags (public and private).");
  const allTags = await tagging._getAllTags({});

  // Effects: All tags (public and private) should be returned
  assertEquals(allTags.length, 3, "Should retrieve all 3 tags (public and private)");
  const allLabels = allTags.map((t) => t.label).sort();
  assertEquals(allLabels, ["secret_topic", "topic1", "topic2"], "All labels should be present");

  console.log("Query _getAllTags tests passed.");
//   await client.close();
});

Deno.test("TaggingConcept: Principle Trace", async () => {
  console.log("--- Principle Trace: Label books to assist in searching and organization ---");
//   const [db, client] = await testDb();
//   const tagging = new TaggingConcept(db);

  // Users
  const user1 = "user:Alice" as ID;
  const user2 = "user:Bob" as ID;

  // Books
  const book1 = "book:MobyDick" as ID;
  const book2 = "book:Foundation" as ID;
  const book3 = "book:1984" as ID;

  // Trace step 1: Various users add tags to books.
  console.log(`\nTrace Step 1: Users add tags to books.`);
  const tag1_u1_b1_classic = (await tagging.addTag({ user: user1, label: "classic", book: book1 })) as { tag: ID };
  const tag2_u1_b2_scifi = (await tagging.addTag({ user: user1, label: "sci-fi", book: book2 })) as { tag: ID };
  const tag3_u2_b1_adventure = (await tagging.addTag({ user: user2, label: "adventure", book: book1 })) as { tag: ID };
  const tag4_u2_b3_dystopian = (await tagging.addTag({ user: user2, label: "dystopian", book: book3 })) as { tag: ID };
  const tag5_u1_b3_private_note = (await tagging.addTag({ user: user1, label: "private_note", book: book3 })) as {
    tag: ID;
  };
  await tagging.markPrivate({ tag: tag5_u1_b3_private_note.tag }); // Make private

  console.log(`User ${user1} added 'classic' to ${book1}, 'sci-fi' to ${book2}, 'private_note' to ${book3} (private).`);
  console.log(`User ${user2} added 'adventure' to ${book1}, 'dystopian' to ${book3}.`);

  let allTags = await tagging._getAllTags({});
  assertEquals(allTags.length, 5, "Total 5 tags should be in DB after initial adds.");
  console.log("All tags in DB: ", allTags.map(t => `${t.user} tags ${t.book} with ${t.label} (private: ${t.private})`));

  // Trace step 2: Then, those books can be displayed in groups by shared tag
  console.log(`\nTrace Step 2: Books displayed in groups by shared tag.`);

  // Display books tagged 'classic'
  console.log(`\nDisplaying books with 'classic' tag (public search):`);
  let classicTags = await tagging._getBooksByLabel({ user: user1, labels: ["classic"], type: 'union' }); // user doesn't matter for public tags
  assertEquals(classicTags.length, 1);
  assertEquals(classicTags[0].book, book1);
  console.log(`Found ${classicTags.length} book(s) with 'classic' tag: ${classicTags.join(", ")}`);

  // Display books tagged 'adventure'
  console.log(`\nDisplaying books with 'adventure' tag (public search):`);
  let adventureTags = await tagging._getBooksByLabel({ user: user1, labels: ["adventure"], type: 'union' });
  assertEquals(adventureTags.length, 1);
  assertEquals(adventureTags[0].book, book1);
  console.log(`Found ${adventureTags.length} book(s) with 'adventure' tag: ${adventureTags.join(", ")}`);

  // Trace step 3: and users can search for books with a specific tag.
  console.log(`\nTrace Step 3: Users search for books with a specific tag.`);

  // User 1 searches for 'sci-fi'
  console.log(`\nUser ${user1} searches for 'sci-fi':`);
  let user1_scifi_books = await tagging._getBooksByLabel({ user: user1, labels: ["sci-fi"], type: 'union' });
  assertEquals(user1_scifi_books.length, 1);
  assertEquals(user1_scifi_books[0].book, book2);
  console.log(`User ${user1} found ${user1_scifi_books.length} book(s) with 'sci-fi': ${user1_scifi_books.join(", ")}`);

  // User 2 searches for 'dystopian'
  console.log(`\nUser ${user2} searches for 'dystopian':`);
  let user2_dystopian_books = await tagging._getBooksByLabel({ user: user2, labels: ["dystopian"], type: 'union' });
  assertEquals(user2_dystopian_books.length, 1);
  assertEquals(user2_dystopian_books[0].book, book3);
  console.log(`User ${user2} found ${user2_dystopian_books.length} book(s) with 'dystopian': ${user2_dystopian_books.join(", ")}`);

  // User 1 searches for their private tag 'private_note' on book3
  console.log(`\nUser ${user1} searches for their private tag 'private_note':`);
  let user1_private_note_books = await tagging._getBooksByLabel({ user: user1, labels: ["private_note"], type: 'union' });
  assertEquals(user1_private_note_books.length, 1);
  assertEquals(user1_private_note_books[0].book, book3);
  console.log(`User ${user1} found ${user1_private_note_books.length} book(s) with 'private_note': ${user1_private_note_books.join(", ")}`);

  // User 2 tries to search for User 1's private tag 'private_note' (should fail)
  console.log(`\nUser ${user2} tries to search for User ${user1}'s private tag 'private_note':`);
  let user2_private_note_books = await tagging._getBooksByLabel({ user: user2, labels: ["private_note"], type: 'union' });
  assertEquals(user2_private_note_books.length, 0, "User2 should not find User1's private tag.");
  console.log(`User ${user2} found ${user2_private_note_books.length} book(s) with 'private_note'.`);

  // Also check _getTagsByBook to verify display/search by book
  console.log(`\nUser ${user1} views all tags on ${book3} (should see their private tag):`);
  let tagsOnBook3_User1 = await tagging._getTagsByBook({ user: user1, book: book3 });
  assertEquals(tagsOnBook3_User1.length, 2, "User1 sees public and their private tags on book3.");
  const book3_labels_user1 = tagsOnBook3_User1.map(t => t.label).sort();
  assertEquals(book3_labels_user1, ["dystopian", "private_note"]);
  console.log(`User ${user1} sees tags: ${book3_labels_user1.join(", ")} on ${book3}.`);

  console.log(`\nUser ${user2} views all tags on ${book3} (should NOT see User1's private tag):`);
  let tagsOnBook3_User2 = await tagging._getTagsByBook({ user: user2, book: book3 });
  assertEquals(tagsOnBook3_User2.length, 1, "User2 sees only public tags on book3.");
  const book3_labels_user2 = tagsOnBook3_User2.map(t => t.label).sort();
  assertEquals(book3_labels_user2, ["dystopian"]);
  console.log(`User ${user2} sees tags: ${book3_labels_user2.join(", ")} on ${book3}.`);

  console.log("\nPrinciple Trace complete and verified.");
//   await client.close();
});

```
